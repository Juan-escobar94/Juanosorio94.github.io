---
title: What is Syzkaller, how does it work? 
date: "2021-02-07T21:44:24.950Z"
description: "post outlining the main aspects of syzkaller"
categories: [code]
comments: true
image: 
  feature: https://github.com/google/syzkaller/blob/master/docs/process_structure.png?raw=true 
  credit: Syzkaller authors 
  creditlink: https://github.com/google/syzkaller/blob/master/docs/process_structure.png?raw=true 
---


# Syzkaller

In this entry I want to outline the main points of 
Syzkaller, a program which fuzzes the linux kernel by generating
programs that execute system calls.

Just for learning purposses, I wanted to fit as much relevant
information (in my ignorant opinion) about syzkaller as possible 
into one blog post. Coherence is not guaranteed ;)


## Goal

Find bugs inside kernel (not restricted to linux).
In order to achieve this, syzkaller starts a defined
amount of VMs, in which the kernel is continously
fuzzed.

## Running Syzkaller


the main entry point of syzkaller is a program called 
syz-manager, which is responsible for managing 
the virtual machines. It also starts an http server which
serves a dashboard with information about crashes,
code coverage, etc.


## How Syzkaller works

Syz-manager starts, monitors and restarts several VM instances, and
starts a syz-fuzzer process inside of the VMs. The Syz-manager is
responsible for persistent corpus and crash storage, it runs on a 
host with a stable kernel which does not experiecne white-noise
fuzzer load.

![Syzkaller Architecture](https://github.com/google/syzkaller/blob/master/docs/process_structure.png?raw=true)

The syz-fuzzer is the process that runs inside the VMs (whose kernel
are the fuzzing target). The syz-fuzzer guides the fuzzing process
(generates inout, mutates and minimizes, among other things)  and
sends input that triggers new coverage via RPC to the syz-manager.
Syz-fuzzer also starts syz-executor processes, which are in charge
of actually executing the programs generated by syz-fuzzer, and then
terminate.

each syz-executor executes a sequence of system calls, which are
given by the syz-fuzzer process, and then sends the results back
to syz-fuzzer. It is written in C++, and designed to be as simple
as possible, so it does not interfere with the fuzzing at all. It is
compiled as a static binary and commmunicates with syz-fuzzer using
shared memory.

## Syzkaller VMs

There are some generic requirements of a Syzkaller VM:

* Networking support, because the fuzzing processes
communicate with the outside world.

* SSH Server, as program files for the fuzzer processes
are transmitted into the VM using SSH.

* SSH config should be set to allow root access.

* A mounted debugfs filesystem, as the kernel
exports coverage information via a debugfs entry. (See KCOV)

as I am interested in fuzzing a specific device driver inside
the linux kernel, I compiled it with all the required instrumentation
(KASAN, KCOV, etc) and also compiled the drivers im interested in as modules

in my case, for the software impl of RoCE (RDMA over
Converged Ethernet) rdma\_rxe, a character device file is 
exposed /dev/infiniband/uverbs after creating a software rdma device,
this is achieved right after login by executing a shell script (using
the .bashrc file)

## Program generation

Syzkaller uses its own language to describe system calls. Because
depending on its use and context, the same system call may provide
a very different function, the need to describe this behaviour
gave entrance to syzkallers system call description language,
syzlang.

inside syzkaller's source tree, this definitions are found
inside /sys/[operatingsystem]/\*.txt files.

A program is a sequence of syscalls with concrete values for 
arguments.

Programs passed to syz-executor are in binary represenation, they
are actually interpreted by /prog/decodeexec.go

# Syzlang

A "Pseudo-formal" grammar used to describe syscalls:

```
syscallname "(" [arg ["," arg]*] ")" [type] ["(" attribute* ")"]
arg = argname type
argname = identifier
type = typename [ "[" type-options "]" ]
typename = "const" | "intN" | "intptr" | "flags" | "array" | "ptr" |
	   "string" | "strconst" | "filename" | "len" |
	   "bytesize" | "bytesizeN" | "bitsize" | "vma" | "proc"
type-options = [type-opt ["," type-opt]]
```



## Crashes

Once a crash is detected in one of the VMs, Syzkaller
will start the process of reproducing the crash and
then minimize the program that causes it. VMs will 
stop fuzzing in order to reproduce detected crashes.

Crash logs are stored inside a directory called
workdir/crashes, it contains the progams that 
were executed just before a crash occured.

Syzkaller programs are generated by a set of system
calls defined by a language called Syzlang, These 
can also be locally executed by syz-execprog and
translated into c with syz-prog2c.

the process of finding a crash reprodution is 
"automated to some degree" with another 
tool inside syzkaller, called syz-repro.
In order to run syz-repro, pass the syzmanager
config file and the crsah report file.

