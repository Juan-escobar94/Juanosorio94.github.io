{"componentChunkName":"component---src-templates-blog-post-js","path":"/Syzkaller/","result":{"data":{"site":{"siteMetadata":{"title":"Juan Osorio"}},"markdownRemark":{"id":"a3614abc-3046-5227-930f-11a1b1a825f5","excerpt":"Syzkaller In this entry I want to outline the main points of \nSyzkaller, a program which fuzzes the linux kernel by generating\nprograms that execute system…","html":"<h1>Syzkaller</h1>\n<p>In this entry I want to outline the main points of\nSyzkaller, a program which fuzzes the linux kernel by generating\nprograms that execute system calls.</p>\n<p>Just for learning purposses, I wanted to fit as much relevant\ninformation (in my ignorant opinion) about syzkaller as possible\ninto one blog post. Coherence is not guaranteed ;)</p>\n<h2>Goal</h2>\n<p>Find bugs inside kernel (not restricted to linux).\nIn order to achieve this, syzkaller starts a defined\namount of VMs, in which the kernel is continously\nfuzzed.</p>\n<h2>Running Syzkaller</h2>\n<p>the main entry point of syzkaller is a program called\nsyz-manager, which is responsible for managing\nthe virtual machines. It also starts an http server which\nserves a dashboard with information about crashes,\ncode coverage, etc.</p>\n<h2>How Syzkaller works</h2>\n<p>Syz-manager starts, monitors and restarts several VM instances, and\nstarts a syz-fuzzer process inside of the VMs. The Syz-manager is\nresponsible for persistent corpus and crash storage, it runs on a\nhost with a stable kernel. </p>\n<p>The syz-fuzzer is the process that runs inside the VMs (whose kernel\nare the fuzzing target). The syz-fuzzer guides the fuzzing process\n(generates inout, mutates and minimizes, among other things)  and\nsends input that triggers new coverage via RPC to the syz-manager.\nSyz-fuzzer also starts syz-executor processes, which are in charge\nof actually executing the programs generated by syz-fuzzer, and then\nterminate.</p>\n<p>each syz-executor executes a sequence of system calls, which are\ngiven by the syz-fuzzer process, and then sends the results back\nto syz-fuzzer. It is written in C++, and designed to be as simple\nas possible, so it does not interfere with the fuzzing at all. It is\ncompiled as a static binary and commmunicates with syz-fuzzer using\nshared memory.</p>\n<p>Programs passed to syz-executor are in binary represenation, they\nare actually interpreted by <code class=\"language-text\">/prog/decodeexec.go</code>.</p>\n<p>The following diagram depicts the architecture of syzkaller, red colored\ntext are configurable options:</p>\n<p><img src=\"https://github.com/google/syzkaller/blob/master/docs/process_structure.png?raw=true\" alt=\"Syzkaller Architecture\"></p>\n<h2>Syzkaller VMs</h2>\n<p>There are some generic requirements of a Syzkaller VM:</p>\n<ul>\n<li>Networking support, because the fuzzing processes\ncommunicate with the outside world.</li>\n<li>SSH Server, as program files for the fuzzer processes\nare transmitted into the VM using SSH.</li>\n<li>SSH config should be set to allow root access.</li>\n<li>A mounted debugfs filesystem, as the kernel\nexports coverage information via a debugfs entry. (See KCOV)</li>\n</ul>\n<p>as I am interested in fuzzing a specific device driver inside\nthe linux kernel, I compiled it with all the required instrumentation\n(KASAN, KCOV, etc) and also compiled the drivers im interested in as modules</p>\n<p>in my case, for the software impl of RoCE (RDMA over\nConverged Ethernet) rdma_rxe, a character device file is\nexposed /dev/infiniband/uverbs after creating a software rdma device,\nthis is achieved right after login by executing a shell script (using\nthe .bashrc file)</p>\n<h2>Program generation</h2>\n<p>Syzkaller uses its own language to describe system calls. Because\ndepending on its use and context, the same system call may provide\na very different function, the need to describe this behaviour\ngave entrance to syzkallers system call description language,\nsyzlang.</p>\n<p>The ability to define system calls in this manner, allows syzkaller to\nunderstand dependencies based input and output variables, which are\ndefined as resources in syzlang. This makes it possible to create\ndependencies between system calls, meaning: a system call that\ncreates a resource, will precede a systemcall that takes this resource\nas an argument.</p>\n<p>As an example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">r0 = open(&amp;(0x7f000000000)=&quot;./file0&quot;, 0x3, 0x9)\nread(r0, &amp;(0x7f0000000100), 42)\nclose(r0)</code></pre></div>\n<p>Here, r0 reprensents a resource (a file descriptor),\nwhich is required for further system calls, namely read and close.</p>\n<h3>Program mutation</h3>\n<p>Based on the coverage metric, syzkaller mutates programs of the corpus,\nit applies this transformations:</p>\n<ul>\n<li>Insert/remove system calls</li>\n<li>\n<p>Change Arguments:</p>\n<ul>\n<li>resize Arrays/Buffers</li>\n<li>change union options</li>\n<li>flags (e.g. file access)</li>\n<li>len/bytesize</li>\n<li>filename</li>\n<li>pointers</li>\n</ul>\n</li>\n<li>\n<p>Taditional mutation of blobs:</p>\n<ul>\n<li>flip bits, insert/remove bytesm etc.</li>\n</ul>\n</li>\n<li>\n<p>Splicing of programs</p>\n<ul>\n<li>based on resources</li>\n</ul>\n</li>\n</ul>\n<h4>Priorization</h4>\n<p>Mutations applied are selected based on priorization\ncriteria, which is done on multiple levels:</p>\n<ul>\n<li>\n<p>Program: </p>\n<ul>\n<li>When choosing a program from a corpus, the main criteria to back this decision are complexity (number of syscalls, number of args, complexity of args) and coverage.</li>\n<li>On program mutation heuristics are applied. For example, removing a system call does not <em>usually</em> cause as much impact on code coverage as adding a system call.</li>\n</ul>\n</li>\n<li>\n<p>system call:</p>\n<ul>\n<li>system calls are selected based on their argument complexity (the more complex, the better), </li>\n<li>static relation to system calls already in the program (system calls that use sockets will be prefered against system calls that use filesystem, if a program already contains system calls that use sockets)</li>\n<li>Dynamic relation to existing system calls. This works\nsimilarly to reinforced learning, system calls that\nfrequently appear together (even if we dont know why),\nit is assumed that there must be a relation between them,\nand this system calls will get inserted into programs\nmore frequently.</li>\n</ul>\n</li>\n<li>\n<p>Argument selection:</p>\n<ul>\n<li>Complexity: arguments with bigger search space get preferred, just because there are more values to test.(64 bit int vs 8 bit int, for example)</li>\n<li>heuristics: changing exact values of pointers usually\ndoesnt provoke new behaviours mor trigger bugs.</li>\n</ul>\n</li>\n<li>\n<p>Argument generation</p>\n<ul>\n<li>Resources: frequency of default values (0/1 for fd)</li>\n<li>flags: how many bits to set</li>\n<li>ints: how often do we use 0? (most of the times special value, hence use more often) </li>\n</ul>\n</li>\n</ul>\n<p><sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>.</p>\n<h2>Extending syzkaller subsystems</h2>\n<p>inside syzkaller’s source tree, definitions for system calls are found\ninside <code class=\"language-text\">/sys/[operatingsystem]/*.txt</code> files.</p>\n<p>A program is a sequence of syscalls with concrete values for\narguments. </p>\n<p>Inside the text files syzkaller subsystems are defined using syzlang.\nThis language allows syzkaller to know about argument types, system call\ninter dependencies and further differentiate things which are treated\nequally in the C language, which makes a lot of sense when defining a subsystem.</p>\n<p>Take as an example the ioctl system call interface, which is kept very general\nfor very good reasons, but is also a whole different thing in between different\ndevices. Syzlang allows a logical differentiation of arguments and instances of\nioctls.</p>\n<h3>Syzlang</h3>\n<p>A “Pseudo-formal” grammar used to describe syscalls:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">syscallname &quot;(&quot; [arg [&quot;,&quot; arg]*] &quot;)&quot; [type] [&quot;(&quot; attribute* &quot;)&quot;]\narg = argname type\nargname = identifier\ntype = typename [ &quot;[&quot; type-options &quot;]&quot; ]\ntypename = &quot;const&quot; | &quot;intN&quot; | &quot;intptr&quot; | &quot;flags&quot; | &quot;array&quot; | &quot;ptr&quot; |\n\t   &quot;string&quot; | &quot;strconst&quot; | &quot;filename&quot; | &quot;len&quot; |\n\t   &quot;bytesize&quot; | &quot;bytesizeN&quot; | &quot;bitsize&quot; | &quot;vma&quot; | &quot;proc&quot;\ntype-options = [type-opt [&quot;,&quot; type-opt]]</code></pre></div>\n<h2>Fault injection</h2>\n<p>Fault injection is another kernel compilation option\nwhich is useful for fuzzing the kernel.</p>\n<p>Explicitly fail kmalloc, page_alloc, futex, IO. This\nis very meaningful in kernel code, because it tests\nerror handling functions, which could provoke a\ncrash if done incorrectly.</p>\n<p>Systemic fault injection is also possible (fail every\nnth-call).</p>\n<h2>Crashes</h2>\n<p>Once a crash is detected in one of the VMs, Syzkaller\nwill start the process of reproducing the crash and\nthen minimize the program that causes it. VMs will\nstop fuzzing in order to reproduce detected crashes.</p>\n<p>Crash logs are stored inside a directory called\nworkdir/crashes, it contains the progams that\nwere executed just before a crash occured.</p>\n<p>Syzkaller programs are generated by a set of system\ncalls defined by a language called Syzlang, These\ncan also be locally executed by syz-execprog and\ntranslated into c with syz-prog2c.</p>\n<p>the process of finding a crash reprodution is\n“automated to some degree” with another\ntool inside syzkaller, called syz-repro.\nIn order to run syz-repro, pass the syzmanager\nconfig file and the crash report file.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p><a href=\"https://www.youtube.com/watch?v=YwX4UyXnhz0&#x26;ab_channel=MicrosoftIsraelR%26DCenter\">https://www.youtube.com/watch?v=YwX4UyXnhz0&#x26;ab_channel=MicrosoftIsraelR%26DCenter</a></p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","frontmatter":{"title":"What is Syzkaller, how does it work?","date":"February 07, 2021","description":"post outlining the main aspects of syzkaller"}}},"pageContext":{"slug":"/Syzkaller/","previous":{"fields":{"slug":"/compilers-1/"},"frontmatter":{"title":"Compilers introduction"}},"next":null}},"staticQueryHashes":["1049812305","2841359383"]}