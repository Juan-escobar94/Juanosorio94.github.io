{"componentChunkName":"component---src-templates-blog-post-js","path":"/Syzkaller/","result":{"data":{"site":{"siteMetadata":{"title":"Juan Osorio"}},"markdownRemark":{"id":"a3614abc-3046-5227-930f-11a1b1a825f5","excerpt":"Syzkaller In this entry I want to outline the main points of \nSyzkaller, a program which fuzzes the linux kernel by generating\nprograms that execute system…","html":"<h1>Syzkaller</h1>\n<p>In this entry I want to outline the main points of\nSyzkaller, a program which fuzzes the linux kernel by generating\nprograms that execute system calls.</p>\n<p>Just for learning purposses, I wanted to fit as much relevant\ninformation (in my ignorant opinion) about syzkaller as possible\ninto one blog post. Coherence is not guaranteed ;)</p>\n<h2>Goal</h2>\n<p>Find bugs inside kernel (not restricted to linux).\nIn order to achieve this, syzkaller starts a defined\namount of VMs, in which the kernel is continously\nfuzzed.</p>\n<h2>Running Syzkaller</h2>\n<p>the main entry point of syzkaller is a program called\nsyz-manager, which is responsible for managing\nthe virtual machines. It also starts an http server which\nserves a dashboard with information about crashes,\ncode coverage, etc.</p>\n<h2>How Syzkaller works</h2>\n<p>Syz-manager starts, monitors and restarts several VM instances, and\nstarts a syz-fuzzer process inside of the VMs. The Syz-manager is\nresponsible for persistent corpus and crash storage, it runs on a\nhost with a stable kernel which does not experiecne white-noise\nfuzzer load.</p>\n<p><img src=\"https://github.com/google/syzkaller/blob/master/docs/process_structure.png?raw=true\" alt=\"Syzkaller Architecture\"></p>\n<p>The syz-fuzzer is the process that runs inside the VMs (whose kernel\nare the fuzzing target). The syz-fuzzer guides the fuzzing process\n(generates inout, mutates and minimizes, among other things)  and\nsends input that triggers new coverage via RPC to the syz-manager.\nSyz-fuzzer also starts syz-executor processes, which are in charge\nof actually executing the programs generated by syz-fuzzer, and then\nterminate.</p>\n<p>each syz-executor executes a sequence of system calls, which are\ngiven by the syz-fuzzer process, and then sends the results back\nto syz-fuzzer. It is written in C++, and designed to be as simple\nas possible, so it does not interfere with the fuzzing at all. It is\ncompiled as a static binary and commmunicates with syz-fuzzer using\nshared memory.</p>\n<h2>Syzkaller VMs</h2>\n<p>There are some generic requirements of a Syzkaller VM:</p>\n<ul>\n<li>Networking support, because the fuzzing processes\ncommunicate with the outside world.</li>\n<li>SSH Server, as program files for the fuzzer processes\nare transmitted into the VM using SSH.</li>\n<li>SSH config should be set to allow root access.</li>\n<li>A mounted debugfs filesystem, as the kernel\nexports coverage information via a debugfs entry. (See KCOV)</li>\n</ul>\n<p>as I am interested in fuzzing a specific device driver inside\nthe linux kernel, I compiled it with all the required instrumentation\n(KASAN, KCOV, etc) and also compiled the drivers im interested in as modules</p>\n<p>in my case, for the software impl of RoCE (RDMA over\nConverged Ethernet) rdma_rxe, a character device file is\nexposed /dev/infiniband/uverbs after creating a software rdma device,\nthis is achieved right after login by executing a shell script (using\nthe .bashrc file)</p>\n<h2>Program generation</h2>\n<p>Syzkaller uses its own language to describe system calls. Because\ndepending on its use and context, the same system call may provide\na very different function, the need to describe this behaviour\ngave entrance to syzkallers system call description language,\nsyzlang.</p>\n<p>inside syzkaller’s source tree, this definitions are found\ninside /sys/[operatingsystem]/*.txt files.</p>\n<p>A program is a sequence of syscalls with concrete values for\narguments.</p>\n<p>Programs passed to syz-executor are in binary represenation, they\nare actually interpreted by /prog/decodeexec.go</p>\n<h1>Syzlang</h1>\n<p>A “Pseudo-formal” grammar used to describe syscalls:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">syscallname &quot;(&quot; [arg [&quot;,&quot; arg]*] &quot;)&quot; [type] [&quot;(&quot; attribute* &quot;)&quot;]\narg = argname type\nargname = identifier\ntype = typename [ &quot;[&quot; type-options &quot;]&quot; ]\ntypename = &quot;const&quot; | &quot;intN&quot; | &quot;intptr&quot; | &quot;flags&quot; | &quot;array&quot; | &quot;ptr&quot; |\n\t   &quot;string&quot; | &quot;strconst&quot; | &quot;filename&quot; | &quot;len&quot; |\n\t   &quot;bytesize&quot; | &quot;bytesizeN&quot; | &quot;bitsize&quot; | &quot;vma&quot; | &quot;proc&quot;\ntype-options = [type-opt [&quot;,&quot; type-opt]]</code></pre></div>\n<h2>Crashes</h2>\n<p>Once a crash is detected in one of the VMs, Syzkaller\nwill start the process of reproducing the crash and\nthen minimize the program that causes it. VMs will\nstop fuzzing in order to reproduce detected crashes.</p>\n<p>Crash logs are stored inside a directory called\nworkdir/crashes, it contains the progams that\nwere executed just before a crash occured.</p>\n<p>Syzkaller programs are generated by a set of system\ncalls defined by a language called Syzlang, These\ncan also be locally executed by syz-execprog and\ntranslated into c with syz-prog2c.</p>\n<p>the process of finding a crash reprodution is\n“automated to some degree” with another\ntool inside syzkaller, called syz-repro.\nIn order to run syz-repro, pass the syzmanager\nconfig file and the crsah report file.</p>","frontmatter":{"title":"What is Syzkaller, how does it work?","date":"February 07, 2021","description":"post outlining the main aspects of syzkaller"}}},"pageContext":{"slug":"/Syzkaller/","previous":{"fields":{"slug":"/compilers-1/"},"frontmatter":{"title":"Compilers introduction"}},"next":null}},"staticQueryHashes":["1049812305","2841359383"]}